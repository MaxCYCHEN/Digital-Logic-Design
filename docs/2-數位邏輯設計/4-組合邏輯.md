## 簡介
[數位電路](/docs/WiKi/數位電路.md)可以分成兩大類，分別是「[組合邏輯電路](../WiKi/組合邏輯電路.md)」([/docs/WiKi/Combinational Logic Circuit](/docs/WiKi/Combinational%20Logic%20Circuit))與「[序向邏輯電路](../WiKi/序向邏輯電路.md)」([Sequential Logic Circuit](../WiKi/Sequential%20Logic%20Circuit.md))兩大類。

「組合邏輯」是由邏輯閘所組合而成，沒有受到回授訊號、時間順序以及記憶狀態而改變，不因內部狀態而改變下一步動作，因此只有「準位觸發」；「[序向邏輯](/docs/WiKi/序向邏輯.md)」則是由[回授電路](/docs/WiKi/回授電路.md)與邏輯閘組合而成，受到回授訊號、時間順序以及記憶狀態而改變，也就是受到內部狀態而改變下一步狀態，除了有「準位觸發」還有「正緣觸發」與「負緣觸發」。

組合邏輯也是[計算機結構 1](../WiKi/計算機結構%201.md)的基礎組成之一，例如組合邏輯的基本元件與「[暫存器](/docs/WiKi/暫存器.md)」組成的「微運算」；「微運算」組成的「[算術邏輯移位單元](/docs/WiKi/算術邏輯移位單元.md)」；[多工器](/docs/WiKi/多工器.md)、[編碼器](/docs/WiKi/編碼器.md)、[三態閘](/docs/WiKi/三態閘.md)組成的「[匯流排](/docs/WiKi/匯流排.md)」；由[解碼器](/docs/WiKi/解碼器.md)、控制邏輯閘組成「[控制單元](/docs/WiKi/控制單元.md)」，皆可以看到組合邏輯的身影，因此此章節是非常重要的。

這也是為什麼大多的[[/docs/WiKi/數位邏輯書籍]]都會以「[加法器](/docs/WiKi/加法器.md)」、「[減法器](/docs/WiKi/減法器.md)」、「[比較器](/docs/WiKi/比較器.md)」、「[解碼器](/docs/WiKi/解碼器.md)」、「[編碼器](/docs/WiKi/編碼器.md)」、「[多工器](/docs/WiKi/多工器.md)」的基本元件作為介紹，因為後續會用在[計算機結構 1](../WiKi/計算機結構%201.md)上面。

## 加法器
加法器是常見的運算元件，也是數位邏輯中基本元件之一，加法器除了加法外可以延伸製作減法、乘法以及除法。

一個加法器包括了加數、被加數、進位、輸出，也因此最小一位元加法器單元有分成兩種，半加法器、全加法器。

而透過半加法器組成的全加法器中，依照速度與特性又分成兩種加法器：「漣波加法器」、「前瞻加法器」，分別以簡單與快速成為兩種的特性。

這邊都會詳細的說明其中原理與推導。

### 一位元半加法器

| a   | b   | sum | carry |
| --- | --- | --- | ----- |
| 0   | 0   | 0   | 0     |
| 0   | 1   | 1   | 0     |
| 1   | 0   | 1   | 0     |
| 1   | 1   | 0   | 1     |

<details>
<summary>Verilog程式碼</summary>

```verilog
```
</details>

<details>
<summary>Verilog測試檔案</summary>

```verilog
```
</details>

<details>
<summary>HDL 程式碼</summary>

```hdl
// This file is part of www.nand2tetris.org
// and the book "The Elements of Computing Systems"
// by Nisan and Schocken, MIT Press.
// File name: projects/02/HalfAdder.hdl

/**
 * Computes the sum of two bits.
 */

CHIP HalfAdder {
    IN a, b;    // 1-bit inputs
    OUT sum,    // Right bit of a + b
        carry;  // Left bit of a + b

    PARTS:
    Xor(a=a, b=b, out=sum);
    And(a=a, b=b, out=carry);
}

```
</details>

### 一位元全加法器

![2021-11-12 17-54-01 的螢幕擷圖](https://i.imgur.com/Y01ZNre.png)

| a   | b   | c   | sum | carry |
| --- | --- | --- | --- | ----- |
| 0   | 0   | 0   | 0   | 0     |
| 0   | 0   | 1   | 1   | 0     |
| 0   | 1   | 0   | 1   | 0     |
| 0   | 1   | 1   | 0   | 1     |
| 1   | 0   | 0   | 1   | 0     |
| 1   | 0   | 1   | 0   | 1     |
| 1   | 1   | 0   | 0   | 1     |
| 1   | 1   | 1   | 1   | 1     |

全加器具有前級進位、和、進位，半加器則只具有和、進位。

使用AND邏輯閘做出來。

<details>
<summary>Verilog程式碼 Assign</summary>

```verilog
module adder_one_assign (a, b, ci, co, sum);
input a, b, ci;
output co, sum;

assign sum = a ^ b ^ ci;
assign co = (a & b) | (a & ci) | (b & ci);

endmodule // adder_one_assign

```
</details>

<details>
<summary>Verilog測試檔案</summary>

```verilog
`timescale 1ns / 1ps

module adder_one_assign_test ();
reg a, b, ci;
wire co, sum;
integer i;

adder_one_assign UUT (.a(a), .b(b), .ci(ci), .co(co), .sum(sum));

initial begin
  for (i = 0; i < 8; i = i + 1)
    begin
      {a, b, ci} = i[2:0];
      #10;
    end
end

initial begin
  #80;
  $finish;
end


endmodule // adder_one_assign_test

```
</details>

<details>
<summary>Verilog程式碼 If</summary>

```verilog
module adder_one_if (a, b, ci, co, sum);
input a, b, ci;
output co, sum;
reg co, sum;


always @ ( a or b or ci ) begin
  if ({a, b, ci} == 0) begin
    {co, sum} = 2'b00;
  end else if ({a, b, ci} == 1) begin
    {co, sum} = 2'b00;
  end else if ({a, b, ci} == 2) begin
    {co, sum} = 2'b00;
  end else if ({a, b, ci} == 3) begin
    {co, sum} = 2'b00;
  end else if ({a, b, ci} == 4) begin
    {co, sum} = 2'b00;
  end else if ({a, b, ci} == 5) begin
    {co, sum} = 2'b00;
  end else if ({a, b, ci} == 6) begin
    {co, sum} = 2'b00;
  end else begin
    {co, sum} = 2'b00;
  end

end

endmodule // adder_one_if

```
</details>

<details>
<summary>Verilog測試檔案</summary>

```verilog
`timescale 1ns / 1ps

module adder_one_if_test ();
reg a, b, ci;
wire co, sum;
integer i;

adder_one_if UUT (.a(a), .b(b), .ci(ci), .co(co), .sum(sum));

initial begin
  for (i = 0; i < 8; i = i + 1)
    begin
      {a, b, ci} = i[2:0];
      #10;
    end
end

initial begin
  #80;
  $finish;
end


endmodule // adder_one_if_test

```
</details>

<details>
<summary>HDL 程式碼</summary>

```hdl
// This file is part of www.nand2tetris.org
// and the book "The Elements of Computing Systems"
// by Nisan and Schocken, MIT Press.
// File name: projects/02/FullAdder.hdl

/**
 * Computes the sum of three bits.
 */

CHIP FullAdder {
    IN a, b, c;  // 1-bit inputs
    OUT sum,     // Right bit of a + b + c
        carry;   // Left bit of a + b + c

    PARTS:
    /* Sum */


    /* Carry */

}
```
</details>

訊號模擬結果：

![2021-11-12 18-06-14 的螢幕擷圖](https://i.imgur.com/I4h8uI1.png)

使用兩個半加器組成全加器，這樣的作法就有點算是漣波加法器的作法，只是是在1位元就這麼做。

<details>
<summary>Verilog程式碼</summary>

```verilog
```
</details>

<details>
<summary>Verilog測試檔案</summary>

```verilog
```
</details>

<details>
<summary>HDL 程式碼</summary>

```hdl
// This file is part of www.nand2tetris.org
// and the book "The Elements of Computing Systems"
// by Nisan and Schocken, MIT Press.
// File name: projects/02/FullAdder.hdl

/**
 * Computes the sum of three bits.
 */

CHIP FullAdder {
    IN a, b, c;  // 1-bit inputs
    OUT sum,     // Right bit of a + b + c
        carry;   // Left bit of a + b + c

    PARTS:
    HalfAdder(a=a, b=b, sum=halfadder1, carry=carry1);
    HalfAdder(a=halfadder1, b=c, sum=sum, carry=carry2);
    Or(a=carry1, b=carry2, out=carry);

}
```
</details>

### 漣波加法器
<details>
<summary>Verilog程式碼</summary>

```verilog
```
</details>

<details>
<summary>Verilog測試檔案</summary>

```verilog
```
</details>

<details>
<summary>HDL 程式碼</summary>

```hdl
```
</details>

### 4位元全加法器
<details>
<summary>Verilog程式碼</summary>

```verilog
module adder_four (sum, co, a, b, ci);
input [3:0] a, b;
input ci;
output [3:0] sum;
output co;

assign {co, sum} = (a + b + ci);

endmodule // adder_four

```
</details>

<details>
<summary>Verilog測試檔案</summary>

```verilog
```
</details>

<details>
<summary>HDL 程式碼</summary>

```hdl
```
</details>

### 16位元全加法器
| a                | b                | out              |
| ---------------- | ---------------- | ---------------- |
| 0000000000000000 | 0000000000000000 | 0000000000000000 |
| 0000000000000000 | 1111111111111111 | 1111111111111111 |
| 1111111111111111 | 1111111111111111 | 1111111111111110 |
| 1010101010101010 | 0101010101010101 | 1111111111111111 |
| 0011110011000011 | 0000111111110000 | 0100110010110011 |
| 0001001000110100 | 1001100001110110 | 1010101010101010 |

<details>
<summary>Verilog程式碼</summary>

```verilog
```
</details>

<details>
<summary>Verilog測試檔案</summary>

```verilog
```
</details>

<details>
<summary>HDL 程式碼</summary>

```hdl
// This file is part of www.nand2tetris.org
// and the book "The Elements of Computing Systems"
// by Nisan and Schocken, MIT Press.
// File name: projects/02/Adder16.hdl

/**
 * Adds two 16-bit values.
 * The most significant carry bit is ignored.
 */

CHIP Add16 {
    IN a[16], b[16];
    OUT out[16];

    PARTS:
    // Put you code here:
    FullAdder(a=a[0], b=b[0], c=false, sum=out[0], carry=carry0);
    FullAdder(a=a[1], b=b[1], c=carry0, sum=out[1], carry=carry1);
    FullAdder(a=a[2], b=b[2], c=carry1, sum=out[2], carry=carry2);
    FullAdder(a=a[3], b=b[3], c=carry2, sum=out[3], carry=carry3);
    FullAdder(a=a[4], b=b[4], c=carry3, sum=out[4], carry=carry4);
    FullAdder(a=a[5], b=b[5], c=carry4, sum=out[5], carry=carry5);
    FullAdder(a=a[6], b=b[6], c=carry5, sum=out[6], carry=carry6);
    FullAdder(a=a[7], b=b[7], c=carry6, sum=out[7], carry=carry7);
    FullAdder(a=a[8], b=b[8], c=carry7, sum=out[8], carry=carry8);
    FullAdder(a=a[9], b=b[9], c=carry8, sum=out[9], carry=carry9);
    FullAdder(a=a[10], b=b[10], c=carry9, sum=out[10], carry=carry10);
    FullAdder(a=a[11], b=b[11], c=carry10, sum=out[11], carry=carry11);
    FullAdder(a=a[12], b=b[12], c=carry11, sum=out[12], carry=carry12);
    FullAdder(a=a[13], b=b[13], c=carry12, sum=out[13], carry=carry13);
    FullAdder(a=a[14], b=b[14], c=carry13, sum=out[14], carry=carry14);
    FullAdder(a=a[15], b=b[15], c=carry14, sum=out[15], carry=carry15);
}
```
</details>

### 前瞻加法器
<details>
<summary>Verilog程式碼</summary>

```verilog
```
</details>

<details>
<summary>Verilog測試檔案</summary>

```verilog
```
</details>

<details>
<summary>HDL 程式碼</summary>

```hdl
```
</details>

### 累加器
| a                | b                | out              |
| ---------------- | ---------------- | ---------------- |
| 0000000000000000 | 0000000000000000 | 0000000000000000 |
| 0000000000000000 | 1111111111111111 | 1111111111111111 |
| 1111111111111111 | 1111111111111111 | 1111111111111110 |
| 1010101010101010 | 0101010101010101 | 1111111111111111 |
| 0011110011000011 | 0000111111110000 | 0100110010110011 |
| 0001001000110100 | 1001100001110110 | 1010101010101010 |

當有二進位數字輸入時，會將輸入二進位資料做 $`+ 1`$ 的動作。

<details>
<summary>Verilog程式碼</summary>

```verilog
```
</details>

<details>
<summary>Verilog測試檔案</summary>

```verilog
```
</details>

<details>
<summary>HDL 程式碼</summary>

```hdl
// This file is part of www.nand2tetris.org
// and the book "The Elements of Computing Systems"
// by Nisan and Schocken, MIT Press.
// File name: projects/02/Inc16.hdl

/**
 * 16-bit incrementer:
 * out = in + 1 (arithmetic addition)
 */

CHIP Inc16 {
    IN in[16];
    OUT out[16];

    PARTS:
    Add16(a=in[0..15], b[1..15]=false, b[0]=true, out=out[0..15]);
   // Put you code here:
}
```
</details>

## 減法器
<details>
<summary>Verilog程式碼</summary>

```verilog
```
</details>

<details>
<summary>Verilog測試檔案</summary>

```verilog
```
</details>

<details>
<summary>HDL 程式碼</summary>

```hdl
// This file is part of www.nand2tetris.org
// and the book "The Elements of Computing Systems"
// by Nisan and Schocken, MIT Press.
// File name: projects/02/FullAdder.hdl

/**
 * Computes the sum of three bits.
 */

CHIP FullAdder {
    IN a, b, c;  // 1-bit inputs
    OUT sum,     // Right bit of a + b + c
        carry;   // Left bit of a + b + c

    PARTS:
    HalfAdder(a=a, b=b, sum=halfadder1, carry=carry1);
    HalfAdder(a=halfadder1, b=c, sum=sum, carry=carry2);
    Or(a=carry1, b=carry2, out=carry);

}

```
</details>

## 乘法器
<details>
<summary>Verilog程式碼</summary>

```verilog
```
</details>

<details>
<summary>Verilog測試檔案</summary>

```verilog
```
</details>

<details>
<summary>HDL 程式碼</summary>

```hdl
```
</details>

## 除法器
<details>
<summary>Verilog程式碼</summary>

```verilog
```
</details>

<details>
<summary>Verilog測試檔案</summary>

```verilog
```
</details>

<details>
<summary>HDL 程式碼</summary>

```hdl
```
</details>

## 比較器
用於數值的比較，通常會有製作大於、小於、等於，或者在序向邏輯電路中透過指令的方式，來達到相同，但通常硬體方式是最快的比較方式。

<details>
<summary>Verilog程式碼</summary>

```verilog
```
</details>

<details>
<summary>Verilog測試檔案</summary>

```verilog
```
</details>

<details>
<summary>HDL 程式碼</summary>

```hdl
```
</details>

## 解碼器
<details>
<summary>Verilog程式碼</summary>

```verilog
```
</details>

<details>
<summary>Verilog測試檔案</summary>

```verilog
```
</details>

<details>
<summary>HDL 程式碼</summary>

```hdl
```
</details>

## 編碼器
<details>
<summary>Verilog程式碼</summary>

```verilog
```
</details>

<details>
<summary>Verilog測試檔案</summary>

```verilog
```
</details>

<details>
<summary>HDL 程式碼</summary>

```hdl
```
</details>

## 多工器
以下是2X1多工器，是多工器的最小單位。

![2021-09-23 00-54-42 的螢幕擷圖](https://i.imgur.com/YweseX5.png)

| a   | b   | sel | out |
| --- | --- | --- | --- |
| 0   | 0   | 0   | 0   |
| 0   | 0   | 1   | 0   |
| 0   | 1   | 0   | 0   |
| 0   | 1   | 1   | 1   |
| 1   | 0   | 0   | 1   |
| 1   | 0   | 1   | 0   |
| 1   | 1   | 0   | 1   |
| 1   | 1   | 1   | 1   |

<details>
<summary>Verilog程式碼</summary>

```verilog
module nand_and (a, b, sel, out);
  input a, b, sel;
  output out;
  wire nand1_out, nand2_out;

  assign nand1_out = ~(a & ~sel);
  assign nand2_out = ~(b & sel);
  assign out = ~(nand1_out & nand2_out);

endmodule // nand_and

```
</details>

<details>
<summary>Verilog測試檔案</summary>

```verilog
```
</details>

<details>
<summary>HDL 程式碼</summary>

```hdl
// This file is part of www.nand2tetris.org
// and the book "The Elements of Computing Systems"
// by Nisan and Schocken, MIT Press.
// File name: projects/01/Mux.hdl

/**
 * Multiplexor:
 * out = a if sel == 0
 *       b otherwise
 */

CHIP Mux {
    IN a, b, sel;
    OUT out;

    PARTS:
    // Put your code here:
    Nand(a=a, b=selbar, out=nand1out);
    Nand(a=b, b=sel, out=nand2out);
    Not(in=sel, out=selbar);
    Nand(a=nand1out, b=nand2out, out=out);
}
```
</details>

### 4X1多工器
<details>
<summary>Verilog程式碼</summary>

```verilog
```
</details>

<details>
<summary>Verilog測試檔案</summary>

```verilog
```
</details>

<details>
<summary>HDL 程式碼</summary>

```hdl
```
</details>

### 16位元並行輸入16位元並行輸出 2X1多工器

| a                | b                | sel | out              |
| ---------------- | ---------------- | --- | ---------------- |
| 0000000000000000 | 0000000000000000 | 0   | 0000000000000000 |
| 0000000000000000 | 0000000000000000 | 1   | 0000000000000000 |
| 0000000000000000 | 0001001000110100 | 0   | 0000000000000000 |
| 0000000000000000 | 0001001000110100 | 1   | 0001001000110100 |
| 1001100001110110 | 0000000000000000 | 0   | 1001100001110110 |
| 1001100001110110 | 0000000000000000 | 1   | 0000000000000000 |
| 1010101010101010 | 0101010101010101 | 0   | 1010101010101010 |
| 1010101010101010 | 0101010101010101 | 1   | 0101010101010101 |

<details>
<summary>Verilog程式碼</summary>

```verilog
```
</details>

<details>
<summary>Verilog測試檔案</summary>

```verilog
```
</details>

<details>
<summary>HDL 程式碼</summary>

```hdl
// This file is part of www.nand2tetris.org
// and the book "The Elements of Computing Systems"
// by Nisan and Schocken, MIT Press.
// File name: projects/01/Mux16.hdl

/**
 * 16-bit multiplexor:
 * for i = 0..15 out[i] = a[i] if sel == 0
 *                        b[i] if sel == 1
 */

CHIP Mux16 {
    IN a[16], b[16], sel;
    OUT out[16];

    PARTS:
      Mux(a=a[0], b=b[0], sel=sel, out=out[0]);
      Mux(a=a[1], b=b[1], sel=sel, out=out[1]);
      Mux(a=a[2], b=b[2], sel=sel, out=out[2]);
      Mux(a=a[3], b=b[3], sel=sel, out=out[3]);
      Mux(a=a[4], b=b[4], sel=sel, out=out[4]);
      Mux(a=a[5], b=b[5], sel=sel, out=out[5]);
      Mux(a=a[6], b=b[6], sel=sel, out=out[6]);
      Mux(a=a[7], b=b[7], sel=sel, out=out[7]);
      Mux(a=a[8], b=b[8], sel=sel, out=out[8]);
      Mux(a=a[9], b=b[9], sel=sel, out=out[9]);
      Mux(a=a[10], b=b[10], sel=sel, out=out[10]);
      Mux(a=a[11], b=b[11], sel=sel, out=out[11]);
      Mux(a=a[12], b=b[12], sel=sel, out=out[12]);
      Mux(a=a[13], b=b[13], sel=sel, out=out[13]);
      Mux(a=a[14], b=b[14], sel=sel, out=out[14]);
      Mux(a=a[15], b=b[15], sel=sel, out=out[15]);
}

```
</details>

### 四路16位元並行輸入 4X1多工器

| a                | b                | c                | d                | sel | out              |
| ---------------- | ---------------- | ---------------- | ---------------- | --- | ---------------- |
| 0000000000000000 | 0000000000000000 | 0000000000000000 | 0000000000000000 | 00  | 0000000000000000 |
| 0000000000000000 | 0000000000000000 | 0000000000000000 | 0000000000000000 | 01  | 0000000000000000 |
| 0000000000000000 | 0000000000000000 | 0000000000000000 | 0000000000000000 | 10  | 0000000000000000 |
| 0000000000000000 | 0000000000000000 | 0000000000000000 | 0000000000000000 | 11  | 0000000000000000 |
| 0001001000110100 | 1001100001110110 | 1010101010101010 | 0101010101010101 | 00  | 0001001000110100 |
| 0001001000110100 | 1001100001110110 | 1010101010101010 | 0101010101010101 | 01  | 1001100001110110 |
| 0001001000110100 | 1001100001110110 | 1010101010101010 | 0101010101010101 | 10  | 1010101010101010 |
| 0001001000110100 | 1001100001110110 | 1010101010101010 | 0101010101010101 | 11  | 0101010101010101 |

<details>
<summary>Verilog程式碼</summary>

```verilog
```
</details>

<details>
<summary>Verilog測試檔案</summary>

```verilog
```
</details>

<details>
<summary>HDL 程式碼</summary>

```hdl
// This file is part of www.nand2tetris.org
// and the book "The Elements of Computing Systems"
// by Nisan and Schocken, MIT Press.
// File name: projects/01/Mux4Way16.hdl

/**
 * 4-way 16-bit multiplexor:
 * out = a if sel == 00
 *       b if sel == 01
 *       c if sel == 10
 *       d if sel == 11
 */

CHIP Mux4Way16 {
    IN a[16], b[16], c[16], d[16], sel[2];
    OUT out[16];

    PARTS:
    // Put your code here:

    Mux16(a=a, b=b, sel=sel[0], out=out1);
    Mux16(a=c, b=d, sel=sel[0], out=out2);
    Mux16(a=out1, b=out2, sel=sel[1], out=out);
}

```
</details>

## 解多工器
![2021-09-23 01-30-57 的螢幕擷圖](https://i.imgur.com/rHzIuOU.png)

| in  | sel | a   | b   |
| --- | --- | --- | --- |
| 0   | 0   | 0   | 0   |
| 0   | 1   | 0   | 0   |
| 1   | 0   | 1   | 0   |
| 1   | 1   | 0   | 1   |

<details>
<summary>Verilog程式碼</summary>

```verilog
module nand_and (a, b, sel, out);
  input in, sel;
  output a, b;

  assign nand1_out = ~(~(in & ~sel));
  assign nand2_out = ~(~(in & sel));

endmodule // nand_and
```
</details>

<details>
<summary>Verilog測試檔案</summary>

```verilog
```
</details>

<details>
<summary>HDL 程式碼</summary>

```hdl
// This file is part of www.nand2tetris.org
// and the book "The Elements of Computing Systems"
// by Nisan and Schocken, MIT Press.
// File name: projects/01/DMux.hdl

/**
 * Demultiplexor:
 * {a, b} = {in, 0} if sel == 0
 *          {0, in} if sel == 1
 */

CHIP DMux {
    IN in, sel;
    OUT a, b;

    PARTS:
    // Put your code here:
    Not(in=sel, out=selbar);
    Nand(a=in, b=selbar, out=sela);
    Not(in=sela, out=a);
    Nand(a=in, b=sel, out=selb);
    Not(in=selb, out=b);
}
```
</details>

### 4x1 解多工器
| in  | sel | a   | b   | c   | d   |
| --- | --- | --- | --- | --- | --- |
| 0   | 00  | 0   | 0   | 0   | 0   |
| 0   | 01  | 0   | 0   | 0   | 0   |
| 0   | 10  | 0   | 0   | 0   | 0   |
| 0   | 11  | 0   | 0   | 0   | 0   |
| 1   | 00  | 1   | 0   | 0   | 0   |
| 1   | 01  | 0   | 1   | 0   | 0   |
| 1   | 10  | 0   | 0   | 1   | 0   |
| 1   | 11  | 0   | 0   | 0   | 1   |

<details>
<summary>Verilog程式碼</summary>

```verilog
```
</details>

<details>
<summary>Verilog測試檔案</summary>

```verilog
```
</details>

<details>
<summary>HDL 程式碼</summary>

```hdl
// This file is part of www.nand2tetris.org
// and the book "The Elements of Computing Systems"
// by Nisan and Schocken, MIT Press.
// File name: projects/01/DMux4Way.hdl

/**
 * 4-way demultiplexor:
 * {a, b, c, d} = {in, 0, 0, 0} if sel == 00
 *                {0, in, 0, 0} if sel == 01
 *                {0, 0, in, 0} if sel == 10
 *                {0, 0, 0, in} if sel == 11
 */

CHIP DMux4Way {
    IN in, sel[2];
    OUT a, b, c, d;

    PARTS:
      DMux(in=in, sel=sel[1], a=dmux2, b=dmux3);
      DMux(in=dmux2, sel=sel[0], a=a, b=b);
      DMux(in=dmux3, sel=sel[0], a=c, b=d);
}

```

</details>

### 8x1 解多工器
| in  | sel | a   | b   | c   | d   | e   | f   | g   | h   |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 0   | 000 | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   |
| 0   | 001 | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   |
| 0   | 010 | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   |
| 0   | 011 | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   |
| 0   | 100 | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   |
| 0   | 101 | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   |
| 0   | 110 | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   |
| 0   | 111 | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   |
| 1   | 000 | 1   | 0   | 0   | 0   | 0   | 0   | 0   | 0   |
| 1   | 001 | 0   | 1   | 0   | 0   | 0   | 0   | 0   | 0   |
| 1   | 010 | 0   | 0   | 1   | 0   | 0   | 0   | 0   | 0   |
| 1   | 011 | 0   | 0   | 0   | 1   | 0   | 0   | 0   | 0   |
| 1   | 100 | 0   | 0   | 0   | 0   | 1   | 0   | 0   | 0   |
| 1   | 101 | 0   | 0   | 0   | 0   | 0   | 1   | 0   | 0   |
| 1   | 110 | 0   | 0   | 0   | 0   | 0   | 0   | 1   | 0   |
| 1   | 111 | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 1   |

<details>
<summary>Verilog程式碼</summary>

```verilog
```
</details>

<details>
<summary>Verilog測試檔案</summary>

```verilog
```
</details>

<details>
<summary>HDL 程式碼</summary>

```hdl
// This file is part of www.nand2tetris.org
// and the book "The Elements of Computing Systems"
// by Nisan and Schocken, MIT Press.
// File name: projects/01/DMux8Way.hdl

/**
 * 8-way demultiplexor:
 * {a, b, c, d, e, f, g, h} = {in, 0, 0, 0, 0, 0, 0, 0} if sel == 000
 *                            {0, in, 0, 0, 0, 0, 0, 0} if sel == 001
 *                            etc.
 *                            {0, 0, 0, 0, 0, 0, 0, in} if sel == 111
 */

CHIP DMux8Way {
    IN in, sel[3];
    OUT a, b, c, d, e, f, g, h;

    PARTS:
    DMux(in=in, sel=sel[2], a=dmux4way1, b=dmux4way2);
    DMux4Way(in=dmux4way1, sel=sel[0..1], a=a, b=b, c=c, d=d);
    DMux4Way(in=dmux4way2, sel=sel[0..1], a=e, b=f, c=g, d=h);

    // Put your code here:
}

```

</details>
